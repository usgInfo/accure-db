/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.accure.db.in;

import com.accure.accure.db.MongoFile;
import com.accure.accure.db.Query;
import com.mongodb.DB;
import com.mongodb.DBCollection;
import com.mongodb.gridfs.GridFSDBFile;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.bson.types.ObjectId;

/**
 *
 * @author sansari
 */
public interface DAO {
    // --------------------------------------------common interfaces -------------------------------------------
    // -------------------------------------------- Insert -------------------------------------------
    // insert single row

    /**
     *
     * @param table name of the table or collection
     * @param primarykey : not used in case of mongodb
     * @param columns : map of keyvalue pairs containing field name and values
     * to store
     * @return : true if successful
     * @throws Exception
     */
    public boolean insert(String table, String primarykey, Map<String, String> columns) throws Exception;

    /**
     *
     * @param table name of the table or collection
     *
     * @param json : This json represents a complete row. The row id is ssystem
     * generated by the underlying db engine to store
     * @return : true if successful
     * @throws Exception
     */
    public String insert(String table, String json) throws Exception;

    // ---------------------------------------------- Fetch ------------------------------------------
    // fetch single row by primary default key
    /**
     *
     * @param table : name of the table or collection.
     * @param primaryKey value of the system generated default primary key by
     * which the records is to be fetched.
     * @param columns : list of names of record fields to be fetched in the
     * result. returns all fields for a row if null is passed.
     * @return map of keyvalue pairs containing field name and value.
     * @throws Exception
     */
    public Map<String, String> fetch(String table, String primaryKey, String[] columns) throws Exception;

    /**
     *
     * @param table : name of the table or collection.
     * @param primaryKey value of the system generated default primary key by
     * which the records is to be fetched.
     *
     *
     * @return Json string representing returned rows.
     * @throws Exception
     */
    public String fetch(String strTable, String strPrimaryKey) throws Exception;

    /**
     *
     * @param table :name of the table or collection.
     * @param primaryKeys :
     * @return : UnsupportedOperationException("Not supported yet.")
     * @throws Exception :UnsupportedOperationException("Not supported yet.")
     */
    public ArrayList<HashMap<String, String>> fetchMultipleRows(String table, String[] primaryKeys) throws Exception;

    // fetch multiple rows using conditions Map<columnName, Map<operator, value>> .. always uses AND logic with multiple columns.
    /**
     *
     * @param table : name of the table or collection
     * @param columns : "Map[columnName, Map[operator, value]]" Sort keyname and
     * sortorder can be apecified along with query conditions as shown in
     * example below.sample code can be referred from unit testcases in
     * MongodbDAOTest.java file Map<"SORTINFOKEY", Map<"SORTKEY", "fname">>
     * Map<"SORTORDERKEY", Map<"SORTORDER", "-1">> Descending sort
     * Map<"SORTORDERKEY", Map<"SORTORDER", "1">> Aescending sort
     * @return : retursn json after fetching multiple rows using conditions
     * Map[columnName, Map[operator, value]] .. supports operators : equal, lt,
     * lte , gt ,gte on individual field values and always uses AND logic with
     * multiple columns.
     * @throws Exception
     */
    //public ArrayList<HashMap<String, String>> fetchRowsByConditions(String table, Map<String, Map<String, String>> columns) throws Exception;
    public String fetchRowsByConditions(String table, Map<String, Map<String, String>> columns) throws Exception;

    // fetch limited multiple rows using conditions Map<columnName, Map<operator, value>> .. always uses AND logic with multiple columns.
    /**
     *
     * @param table : name of the table or collection
     * @param columns : Map[columnName, Map[operator, value]] Sort keyname and
     * sortorder can be apecified along with query conditions as shown in
     * example below . sample code can be referred from unit testcases in
     * MongodbDAOTest.java file Map<"SORTINFOKEY", Map<"SORTKEY", "fname">>
     * Map<"SORTORDERKEY", Map<"SORTORDER", "-1">> Descending sort
     * Map<"SORTORDERKEY", Map<"SORTORDER", "1">> Aescending sort
     * @param limit : max number of rows to be returned.
     * @return : returns JSON string after fetching multiple rows using
     * conditions Map[columnName, Map[operator, value]] .. supports operators
     * :equal, lt, lte , gt ,gte on individual field values and always uses AND
     * logic with multiple columns.
     * @throws Exception
     */
    public String fetchRowsByConditions(String table, Map<String, Map<String, String>> columns, int limit) throws Exception;

    /**
     *
     * @param strTable
     * @param conditions
     * @return count of rows matching the query.
     * @throws Exception
     */
    public int getCount(String strTable, Map<String, String> conditions) throws Exception;

    // ----------------------------------------------- Delete -------------------------------------------
    // Delete a single column
    // Delete multiple columns
    // Delete a row
    // Delete multiple rows
    /**
     *
     */
    public void close();

    // ----------------------------------------------- DB Specific supports-------------------------------------------
    // ----------------------------------------------- MongoDB Support-------------------------------------------
    // -------------------------------------------- Insert ------------------------------------------------------
    /**
     *
     * @param table : name of the table or collection
     * @param columns : map of keyvalue pairs containing field name and values
     * to store
     * @return : returns the default id created by mongodb and stored in field
     * "_id"
     * @throws Exception
     */
    public String insert(String table, Map<String, String> columns) throws Exception;

    /**
     *
     * @param table : name of the table or collection
     * @param primarykey : not used in case of mongodb
     * @param columns : map of keyvalue pairs containing field name and values
     * to store
     * @param dummy : Not used , created for preventing signature clash. can
     * pass null.
     * @return : returns the default id created by mongodb and stored in field
     * "_id"
     * @throws Exception
     */
    public String insert(String table, String primarykey, Map<String, String> columns, String dummy) throws Exception;

    /**
     *
     * @param table : name of the table or collection
     * @param primarykey : used defined primary key name
     * @param primaryvalue : used defined primary key value
     * @param columns : map of keyvalue pairs containing field name and values
     * to store excluding primary key
     * @return : returns the default id created by mongodb and stored in field
     * "_id"
     * @throws Exception
     */
    public String insert(String table, String primarykey, String primaryvalue, Map<String, String> columns) throws Exception;
    // -------------------------------------------- update -------------------------------------------
    //update single row based on primary key

    /**
     *
     * @param table : name of the table or collection
     * @param primarykey : value of the primary key "_id" in mongodb
     * @param columns : map of keyvalue pairs of record fields to be updated.
     * @return : true if succesful
     * @throws Exception
     */
    public boolean update(String table, String primarykey, String json) throws Exception;

    // -------------------------------------------- table Array list handlers -------------------------------------------
    //create a list to be added to a table row based on primary key
    /**
     *
     * @param table : name of the table or collection
     * @param primarykey : value of the primary key "_id" in mongodb
     * @param listname : name of the list to be created for this row.
     * @param list : Arraylist of strings to be created
     * @return : true if successful
     * @throws Exception
     */
    public boolean createlist(String table, String primarykey, String listname, ArrayList list) throws Exception;
    //get contents of list for a table row based on primary key

    /**
     *
     * @param table : name of the table or collection
     * @param primarykey : value of the primary key "_id" in mongodb
     * @param listname : name of the list whose contents atre to be fetched.
     * @return : returns string array of contents of the list
     * @throws Exception
     */
    public String[] getlist(String table, String primarykey, String listname) throws Exception;
    //add an element to list for a table row based on primary key

    /**
     *
     * @param table : name of the table or collection
     * @param primarykey : value of the primary key "_id" in mongodb
     * @param listname : name of the list to to which the element is to be
     * added.
     * @param listvalue : value to be added to the list.
     * @return : true if successful
     * @throws Exception
     */
    public boolean addtolist(String table, String primarykey, String listname, String listvalue) throws Exception;
    //remove an element from list for a table row based on primary key

    /**
     *
     * @param table : name of the table or collection
     * @param primarykey : value of the primary key "_id" in mongodb
     * @param listname : name of the list from which the element is to be
     * removed.
     * @param listvalue : value to be removed from the list.
     * @return : true if successful
     * @throws Exception
     */
    public boolean deletefromlist(String table, String primarykey, String listname, String listvalue) throws Exception;

    // ---------------------------------------------- Fetch ------------------------------------------
    // fetch single row by any unique user defined primary key along with list of fields to be retrived
    /**
     *
     * @param table : name of the table or collection
     * @param fieldname : user defined primary key field name
     * @param fieldValue : user defined primary key field value
     * @param columns : list of columns to be returned in the result
     * @return : Map of keyvalue pairs containing the result set column values
     * @throws Exception
     */
    public Map<String, String> fetch(String table, String fieldname, String fieldValue, String[] columns) throws Exception;

    // fetch multiple rows using equals-condition  Map<field name, fieldvalue> .. always uses AND logic with multiple columns.
    //multiple fields match can be specified : ex ;name=xyz, age=34,state=texas etc
    /**
     *
     * @param table : name of the table or collection
     * @param conditions : Map of key value pairs to be matched with an equal
     * condition with AND logic operation. multiple fields match can be
     * specified : ex ;name=xyz AND age=34 AND state=texas etc
     * @return : Json string as result rows that match the query conditions.
     * @throws Exception
     */
    public String fetchAllRowsByConditions(String table, Map<String, String> conditions) throws Exception;

    /**
     *
     * @param table : name of the table or collection
     * @param conditions : Map of key value pairs to be matched with an regex
     * condition with OR logic operation. multiple fields match can be specified
     * : ex ;name like xyz , age like 34 , state like texas etc ex:
     * conditions.put("SORTKEY", "fname"); to specify one filed on which to sort
     * ex: conditions.put("SORTORDER", "1");to specify sort in ascending order
     * ex: conditions.put("SORTORDER", "-1");to specify sort in descending order
     * @param strLogic : the logical operation required , valid values are "and"
     * , "or" , default is "and"
     * @return : Json string containing the result rows that match the query
     * conditions.
     * @throws Exception
     */
    public String fetchAllRowsLike(String table, Map<String, String> conditions, String strLogic) throws Exception;

    /**
     *
     * @param table : name of the table or collection
     * @param columns : "Map[columnName, Map[operator, value]]" Sort keyname and
     * sortorder can be apecified along with query conditions as shown in
     * example below. sample code can be referred from unit testcases in
     * MongodbDAOTest.java file Map<"SORTINFOKEY", Map<"SORTKEY", "fname">>
     * Map<"SORTORDERKEY", Map<"SORTORDER", "-1">> Descending sort
     * Map<"SORTORDERKEY", Map<"SORTORDER", "1">> Aescending sort
     * @param strLogic : the logical operation required , valid values are "and"
     * , "or" , default is "and"
     * @return : fetches multiple rows using conditions Map[columnName,
     * Map[operator, value]] .. supports operators : equal, lt, lte , gt ,gte on
     * individual field values uses condition specified in strLogic parameter
     * with multiple columns.
     * @throws Exception
     */
    public String fetchRowsByConditions(String table, Map<String, Map<String, String>> columns, String strLogic) throws Exception;

    /**
     *
     * @param strTable : name of the table or collection
     * @param strPrimaryKey : value of the primary key "_id" in mongodb
     * @param strMapName : name of the list to be created for this row.
     * @param keyValues : key value pairs to be stored
     * @return : true if successful
     * @throws Exception
     */
    //create embedded map of key value pairs for a table row based on primary key
    public boolean createMap(String strTable, String strPrimaryKey, String strMapName, Map keyValues) throws Exception;
    //get contents of embedded map -key value pairs for a table row based on primary key

    /**
     *
     * @param strTable : name of the table or collection
     * @param strPrimaryKey : value of the primary key "_id" in mongodb
     * @param strMapName :name of the map to be fetched for this row.
     * @return Map containing key value pairs.
     * @throws Exception
     */
    public Map getMap(String strTable, String strPrimaryKey, String strMapName) throws Exception;

    //remove an element from the contents of embedded map -key value pairs for a table row based on primary key
    /**
     *
     * @param strTable :name of the table or collection
     * @param strPrimaryKey : value of the primary key "_id" in mongodb
     * @param strMapName :name of the map to be fetched for this row.
     * @param strKeyName :name of the key to be removed from the map.
     * @return true if successful in deleting the key value from the map
     * @throws Exception
     */
    public boolean deleteFromMap(String strTable, String strPrimaryKey, String strMapName, String strKeyName) throws Exception;

    //update or add an element from the contents of embedded map -key value pairs for a table row based on primary key
    /**
     *
     * @param strTable :name of the table or collection
     * @param strPrimaryKey : value of the primary key "_id" in mongodb
     * @param strMapName :name of the map to be fetched for this row
     * @param strKeyName :name of the key to be updated/added to the map.
     * @param KeyValue :value of the key to be updated/added to the map
     * @return : true if successful in updating the key value to the map
     * @throws Exception
     */
    public boolean updateToMap(String strTable, String strPrimaryKey, String strMapName, String strKeyName, String KeyValue) throws Exception;

    //General purpose a binary file storage in mongo db
    /**
     *
     * @param strFilePath:input file path
     * @param strDocType :name of user defined document type/category
     * eg:financial, medical, etc
     * @param strOwnerID :name of the primary key (_id) from the collection or
     * table to which this file is associated.
     * @return : Documentid "_id" in the mongodb db.fs.files collection.
     * @throws IOException
     */
    public String storeBinaryFile(String strFilePath, String strDocType, String strOwnerID, String folderName) throws IOException;

    /**
     * IN- Query support is implemented by this method. Allows search for a set
     * of match values in a specific field across several records.
     *
     * @param table : name of the table or collection
     * @param strInFieldName : The field name in which to search for matches.
     * @param matchValues : The values to be matched in the strInFieldName
     * @param strSortKey : The field name on which to sort the results
     * @param strSortOrder : The sort Order string eg "-1" for descending sort
     * and "1" for ascending sort
     * @return :Arraylist of hashmap containing the result rows that match the
     * query conditions.
     * @throws Exception
     */
    public String fetchRowsByConditions(String table, String strInFieldName, String[] matchValues, String strSortKey, String strSortOrder) throws Exception;

    public String fetchRowsByConditions(String strTable, String columnName, List<String> matchValues, String strSortKey, String strSortOrder) throws Exception;

    /**
     *
     * @param table : name of the table or collection
     * @param conditions : Map of key value pairs to be matched with an regex
     * condition with OR logic operation. multiple fields match can be specified
     * : ex ;name like xyz , age like 34 , state like texas etc ex:
     * conditions.put("SORTKEY", "fname"); to specify one filed on which to sort
     * ex: conditions.put("SORTORDER", "1");to specify sort in ascending order
     * ex: conditions.put("SORTORDER", "-1");to specify sort in descending order
     * @param strLogic : the logical operation required , valid values are "and"
     * , "or" , default is "and"
     * @return : Json string containing the result rows that match the query
     * conditions.
     * @param fromIndex : start index from the result from where the first row
     * is fetched
     * @param limit : upto index from the result set where the last row is
     * fetched
     * @throws Exception
     */
    public String fetchRowsLike(String table, Map<String, String> conditions, String strLogic, int fromIndex, int limit) throws Exception;

    public GridFSDBFile getDbFile(String fileID, String folderName);

    public InputStream getDbFileInputStream(String fileID, String folderName);

    public boolean getToFileSystem(String fileID, String folderName, String outFilePath) throws IOException;

    public String listAllFiles(String OwnerId, String folderName);

    public MongoFile getGridFsFile(String fileID, String folderName) throws IOException;

    public boolean removeFileFromDb(String fileID, String folderName) throws IOException;

    public String storeBinaryFile(MongoFile mf) throws IOException;

    public String fetchRowsByConditions(String table, List<Query> qlist) throws Exception;

    public String fetchDistinctList(String table, String columnname);

    /**
     * IN- Query support is implemented by this method. Allows search for a set
     * of match values in a mongo primary key field _id field across several
     * records.
     *
     * @param table : name of the table or collection
     * @param strInFieldName : The field name in which to search for matches.
     * @param matchValues : The values to be matched in the strInFieldName
     * @param strSortKey : The field name on which to sort the results
     * @param strSortOrder : The sort Order string eg "-1" for descending sort
     * and "1" for ascending sort
     * @return :Arraylist of hashmap containing the result rows that match the
     * query conditions.
     * @throws Exception
     */
    public String fetchRowsByConditions(String table, List<ObjectId> matchValues, String strSortKey, String strSortOrder) throws Exception;

    /**
     *
     * @param folderName : Name of the folder in which the file exist
     * @param conditions : Map of key value pairs as conditions, We can also
     * specify the logical operator with OPERATOR = "and" ,OPERATOR = "or". By
     * default if we did not specify the operator then AND will be applied
     * @return
     * @throws Exception
     */
    public String listAllFilesByCondition(String folderName, HashMap<String, String> conditions) throws Exception;

    public String fetchRowsByDatePeriods(String strTable, String strDateColName, String strStartDate, String strEndDate, Map<String, Map<String, String>> columns) throws Exception;

    public String fetchAll(String strTable) throws Exception;

    public long countAll(String strTable) throws Exception;

    public boolean deleteDocument(String strTable, String strPrimaryKey) throws Exception;

    public boolean delete(String strTable, String strPrimaryKey) throws Exception;

    public String searchFromMultiColumn(String table, Map<String, Object> conditions, String strLogic, int fromIndex, int limit) throws Exception;
     public String searchFromMultiColumnMore(String table, Map<String, Object> conditions, String strLogic, int fromIndex, int limit) throws Exception;

    /**
     * <p>
     * This method accepts
     * <ul>
     * <li>table name - it will be the table name in which conditions have to be
     * applied, </li>
     * <li>condition (Map/Set) - <br>1. If 'match' clause has to be applied,
     * then input parameter should be a Map (Map should contain a key value pair
     * with column name and the value)
     * <br>2. If 'group' clause has to be applied, then input parameter should
     * be a Set (Set should contain column name/s. If multiple columns are
     * passed, distinct elements of those columns with cross product will be the
     * result)
     * <br>3. If 'sort' clause has to be applied, then input parameter should be
     * a Map (Map should contain a key value pair with column name and the
     * value. If group clause is applied, then sort can be applied only with _id
     * and/or count else any column name/s can be passed)</li>
     * <li>Match condition - it is an optional parameter which can be either
     * AND/OR/null</li></ul></p>
     * <p>
     * Eg:</p>
     * <pre>
     *   Map<String, String> matchMap = new HashMap<String, String>();
     *    matchMap.put("colName", "colValue");
     *   Set<String> groupSet = new HashSet<String>();
     *    groupSet.add("colName");
     *   Map<String, Integer> sortMap = new HashMap<String, Integer>();
     *    sortMap.put("_id/count", -1); // if group clause is used
     *            (or)
     *    sortMap.put("colName",1/-1);
     *   Map<String, Object> conditionMap = new HashMap<String, Object>();
     *    conditionMap.put("match", matchMap);
     *    conditionMap.put("sort", sortMap);
     *    conditionMap.put("group", groupSet);
     *   String result = instance.aggregateWithMatchGroupAndSort("table_name", conditionMap, "and/or");
     * </pre>
     * </p>
     *
     * @param strTable
     * @param cond
     * @param matchCond
     * @return JSON String
     * @throws Exception
     */
    public String aggregateWithMatchGroupAndSort(String strTable, Map<String, Object> cond, String matchCond) throws Exception;

    /**
     * @author chaitu
     * @param table : name of the table or collection
     * @param conditions : Map of key value pairs to be matched with an regex
     * condition with OR logic operation. multiple fields match can be specified
     * : ex ;name like xyz , age like 34 , state like texas etc ex:
     * conditions.put("SORTKEY", "fname"); to specify one filed on which to sort
     * ex: conditions.put("SORTORDER", "1");to specify sort in ascending order
     * ex: conditions.put("SORTORDER", "-1");to specify sort in descending
     * order.
     * @param fromIndex : start index from the result from where the first row
     * is fetched
     * @param limit : upto index from the result set where the last row is
     * fetched
     * @throws Exception
     */
    public String fetchRowsByConditions(String strTable, Map<String, String> conditions, int fromIndex, int limit) throws Exception;

    public DB getDB() throws Exception;

    public boolean insertMultiple(String strTable, String json) throws Exception;

   
}
